#!/bin/bash
ME=`basename $0`
HOST=0
DEVICE=0
RESET_BAUD=0
PARAMS=""
SESSION=$(date +%Y%m%d%H%M%S)_$(cat /dev/urandom | tr -cd [:alnum:] | head -c 8)
CONTROL_PATH='ControlPath=~/.ssh/%r@%h:%p.conn.'$SESSION
WORKING_DIR=$(pwd)
EXECUTION_ATTEMPTS=1
PRE_COMMAND=""
POST_COMMAND=""


# Parse the remote path given into a host and device.
function parseRemote {
  arr=(${1//:/ })
  HOST=${arr[0]}
  DEVICE=${arr[1]}

  if [[ -z "$DEVICE" ]]; then
    printf "[$ME] Programmer port not specified\\n"
  else
    # Put the device into the params for the remote.
    PARAMS="$PARAMS -P $DEVICE"
  fi
}

function parsePreCommand {
  PRE_COMMAND=$@
}

function parsePostCommand {
  POST_COMMAND=$@
}

function parseRetryCommand {
  EXECUTION_ATTEMPTS=$1+1
}

function parseProgrammer {
  if [[ $1 == "arduino" ]]; then
    RESET_BAUD=1
  fi
  PARAMS="$PARAMS -c $1"
}

function parseMemoryOperation {
  # Split memory operation into array
  arr=(${1//:/ })
  length=${#arr[@]}

  # Determine type of operation
  case ${arr[1]} in
    r) MEM_OP_TYPE=1 ;;
    v) MEM_OP_TYPE=2 ;;
    w) MEM_OP_TYPE=3 ;;
  esac

  # Path to local file
  FILE_PATH=${arr[2]}

  if [[ ${arr[0]} == "flash" ]]; then
    # Use a session specific filename on remote
    BASE_FILENAME="${FILE_PATH##*/}_$SESSION"
  else
    # This is not really needed, since fuses are always probably specified on the command line?
    BASE_FILENAME="${FILE_PATH##*/}"
  fi

  arr[2]=$BASE_FILENAME

  # Rejoin array and add to params
  SAVE_IFS=$IFS
  IFS=":"
  REMOTE_MEMORY_OPERATION="${arr[*]}"
  IFS=$SAVE_IFS
  PARAMS="$PARAMS -U $REMOTE_MEMORY_OPERATION"
}

function connect {
  printf "[$ME] Connecting to remote host...\\n"
  if ssh -NfM -o $CONTROL_PATH $HOST; then
    printf "[$ME] Connected\\n"
  else
    return 1
  fi
}

function disconnect {
  printf "[$ME] Disconnecting from remote host..."
  ssh -o $CONTROL_PATH -O exit $HOST
  printf "\\n"
}

function copyToRemote {
  printf "[$ME] Copying file to remote host...\\n"
  scp -o $CONTROL_PATH $FILE_PATH $HOST:~/$BASE_FILENAME
}

function pre_command {
  if [[ -n "$PRE_COMMAND" ]]; then
    printf "[$ME] Executing pre-command $PRE_COMMAND...\\n"
    ssh -o $CONTROL_PATH $HOST "$PRE_COMMAND"
  fi
}

function execute {
  for (( i=1; i<=$EXECUTION_ATTEMPTS; i++ )); do
    printf "[$ME] Attempt $i...\\n"
    if ssh -o $CONTROL_PATH $HOST "avrdude $PARAMS"; then
      return
    else
      printf "[$ME] Attempt $i failed!\\n"
    fi
  done
  return 1
}

function post_command {
  if [[ -n "$POST_COMMAND" ]]; then
    printf "[$ME] Executing post-command $POST_COMMAND...\\n"
    ssh -o $CONTROL_PATH $HOST "$POST_COMMAND"
  fi
}

function resetBaud {
  printf "[$ME] Reseting baudrate...\\n"
  ssh -o $CONTROL_PATH $HOST "stty -F $DEVICE 1200"
  sleep 1
}

function copyFromRemote {
  printf "[$ME] Copying file from remote host...\\n"
  scp -o $CONTROL_PATH $HOST:~/$BASE_FILENAME $FILE_PATH
}

function delete {
  printf "[$ME] Deleting file from remote host..."
  ssh -o $CONTROL_PATH $HOST "rm ~/$BASE_FILENAME"
  printf "Done\\n"
}


# Parse the parameters
for i in "$@"; do
  case $i in
    -P) CASE_REMOTE_PATH=1; continue ;;
    -U) CASE_MEMORY_OPERATION=1; continue ;;
    -c) CASE_PROGRAMMER_OPERATION=1; continue ;;
    --pre) CASE_PRE_COMMAND=1; continue ;;
    --post) CASE_POST_COMMAND=1; continue ;;
    --retry) CASE_RETRY_COMMAND=1; continue ;;
    *)
      # Also handle cases where there is no space between the parameter key and value
      if [[ $i == -P* ]]; then
        i=${i#-P}
        parseRemote $i
      elif [[ $i == -U* ]]; then
        i=${i#-U}
        parseMemoryOperation $i
      elif [[ $i == -c* ]]; then
        i=${i#-c}
        parseProgrammer $i
      elif [[ $i == --pre* ]]; then
        i=${i#--pre}
        parsePreCommand $i
      elif [[ $i == --post* ]]; then
        i=${i#--post}
        parsePostCommand $i
      elif [[ $i == --retry* ]]; then
        i=${i#--retry}
        parseRetryCommand $i
      fi
      ;;
  esac

  if [[ $CASE_REMOTE_PATH -eq 1 ]]; then
    parseRemote $i
    CASE_REMOTE_PATH=0
    continue
  fi

  if [[ $CASE_MEMORY_OPERATION -eq 1 ]]; then
    parseMemoryOperation $i
    CASE_MEMORY_OPERATION=0
    continue
  fi

  if [[ $CASE_PROGRAMMER_OPERATION -eq 1 ]]; then
    parseProgrammer $i
    CASE_PROGRAMMER_OPERATION=0
    continue
  fi

  if [[ $CASE_PRE_COMMAND -eq 1 ]]; then
    parsePreCommand $i
    CASE_PRE_COMMAND=0
    continue
  fi

  if [[ $CASE_POST_COMMAND -eq 1 ]]; then
    parsePostCommand $i
    CASE_POST_COMMAND=0
    continue
  fi

  if [[ $CASE_RETRY_COMMAND -eq 1 ]]; then
    parseRetryCommand $i
    CASE_RETRY_COMMAND=0
    continue
  fi

  PARAMS="$PARAMS $i"
done

#echo "Avrdue parameters $PARAMS"

result=1

if connect; then
  if [[ $RESET_BAUD -eq 1 ]]; then
    resetBaud
  fi

  # No memory operations, just run avrdude with the provided options
  if [[ $MEM_OP_TYPE -eq 0 ]]; then
    if pre_command; then
      printf "[$ME] Executing avrdude..."
      if execute; then
        post_command
      fi
    fi
  fi

  # Read requested from board
  if [[ $MEM_OP_TYPE -eq 1 ]]; then
    if pre_command; then
      printf "[$ME] Reading from board..."
      if execute; then
        if post_command; then
          if copyFromRemote; then
            result=0
          fi
        fi
        delete
      fi
    fi
  fi

  # Image verification requested
  if [[ $MEM_OP_TYPE -eq 2 ]]; then
    if copyToRemote; then
      if pre_command; then
        printf "[$ME] Verifying..."
        if execute; then
          printf "[$ME] Verification succeeded!"
          post_command
          result=0
        else
          printf "[$ME] Verification failed!"
        fi
      fi
      delete
    fi
  fi

  # Upload to board requested
  if [[ $MEM_OP_TYPE -eq 3 ]]; then
    if copyToRemote; then
      if pre_command; then
        printf "[$ME] Uploading to board...\\n"
        if execute; then
          printf "[$ME] Upload succeeded!"
          post_command
          result=0
        else
          printf "[$ME] Upload failed!"
        fi
      fi
      delete
    fi
  fi

  disconnect
fi

exit $result
